//Para merkle inclusion
import "hashes/sha256/512bit" as hash;
import "hashes/sha256/256bitPadded" as leafHash;
import "hashes/utils/256bitsDirectionHelper" as multiplex;

//Para voto valido
import "ecc/babyjubjubParams" as Params;
import "ecc/edwardsAdd" as ecAdd;
import "ecc/edwardsScalarMult" as ecMul;

// Merkle Inclusion
const u32 DEPTH = 2;
const u32[8] root = [0x6e91d0d2,0x78aa6339,0xc4c452ac,0xf6e51270,0x8aa5bd3b,0xc1e92ee5,0x0815a83d,0x371f8b2e]; //Raiz del Merkle Tree

def select(bool condition, u32[8] left, u32[8] right) -> (u32[8], u32[8]) {
    return (condition ? right : left, condition ? left : right);
}

def checkMerkleInclusion(u32[8] token, bool[DEPTH] directionSelector, u32[DEPTH][8] path) -> bool {
    u32[8] leaf = leafHash(token);
    u32[8] mut digest = leaf;

    for u32 i in 0..DEPTH {
        (u32[8], u32[8]) s = select(directionSelector[i], digest, path[i]);
        digest = hash(s.0, s.1);
    }

    bool mut isEqual = true;
    for u32 i in 0..8{
        isEqual = digest[i] == root[i];
    }
    return isEqual;
}

struct Point{
    field x;
    field y;
}

//Valid Vote
 // Clave pública
const field Hx = 16142091703924503772780067265669780561498485135382805743846124708954689813034911006852326328839918222838196966452269891008793626011888116387645890115679;
const field Hy = 16142091703924503772780067265669780561498485135382805743846124708954689813034911006852326328839918222838196966452269891008793626011888116387645890115679;

def validVote(
    // --- PUBLICOS --- 
    // Estos valores van a ser los que se guarden en el smart contract, sumados con los demas votos y luego desencriptados por la private key para calcular el total
    Point C1,     // rG
    Point C2,     // mG + rH

    // --- PRIVADOS ---
    field r,
    bool vote      // voto (0 o 1)
) -> bool {
    field m = if vote { 1 } else { 0 };

    
    Point G = Params.g;
    Point H = 

    assert(rG.x == C1.x);
    assert(rG.y == C1.y);

    Point rH = ecMul(r, H);

    Point mG = ecMul(m, G);
    Point expectedC2 = ecAdd(mG, rH);

    assert(expectedC2.x == C2.x);
    assert(expectedC2.y == C2.y);
    return true;
}

//Funcion principal
def main( 
    //Parámetros para merkleInclusion
    //Privados
    private u32[8] token,
    private bool[DEPTH] directionSelector,
    private u32[DEPTH][8] path,

    //Parametros para ValidVote

    //Publicos
    Point c1,
    Point c2,

    //Privados
    private bool vote,
    private u32 r,

    //Para el nullifier
    private field nullifier //TO DO
    ){
    
    assert(checkMerkleInclusion(token, directionSelector, path));
    assert(validVote(C1, C2, r, vote));
    assert(nullifier == hash(token, g)); // Lo hago de esta manera ya que el nullifier es público, para que no se pueda saber fácilmente que hojas del árbol votaron.
    return true;
}